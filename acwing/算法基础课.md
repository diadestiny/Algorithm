# 快速排序

1. 确定分界点 左、中、右、随机
2. 调整范围 <= x ; >=x (双指针做法)
3. 递归处理左右两段

```c++
void quick_sort(int q[],int l,int r){
    if(l == r) return ;
    int x = q[(l+r)/2];
    int i = l-1;
    int j = r+1;
    while(i<j){
        do i++; while(q[i]<x);
        do j--; while(q[j]>x);
        if(i<j) swap(q[i],q[j]);
    }
    quick_sort(q,l,j);
    quick_sort(q,j+1,r);
    
}
```

# 快速选择

```c++
int quick_select(int l,int r,int k){
    if(l==r) return q[(l+r)/2];
    int i=l-1;int j = r+1; int x= q[(l+r)/2];
    
    while(i<j){
        do i++; while(q[i]<x);
        do j--; while (q[j]>x);
        if(i<j) swap(q[i],q[j]);
    }
    
    if(k<=j-l+1) quick_select(l,j,k);
    else quick_select(j+1,r,k-(j-l+1));
}
```

# 归并排序

1. 确定分界点 mid = (l+r)/2

2. 递归排序 left、right

3. 归并合二为一（重要）

   ```c++
   void merge_sort(int q[],int l,int r){
       if(l>=r) return ;
       int mid = (l+r)/2;
       merge_sort(q,l,mid);
       merge_sort(q,mid+1,r);
       int i = l;
       int j = mid + 1;
       int k = 0;
       while(i<=mid && j <= r){
           if(q[i]<q[j]) tmp[k++] = q[i++];
           else tmp[k++] = q[j++];
       }
       while(i<=mid){
           tmp[k++] = q[i++];
       }
       while(j<=r){
           tmp[k++] = q[j++];
       }
       for(k=l,j=0;k<=r;k++,j++) q[k] = tmp[j];
   }
   ```

   

