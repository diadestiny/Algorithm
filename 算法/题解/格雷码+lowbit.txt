格雷码是以n位的二进制来表示数。
与普通的二进制表示不同的是，它要求相邻两个数字只能有1个数位不同。
首尾两个数字也要求只有1位之差。

有很多算法来生成格雷码。以下是较常见的一种：
从编码全0开始生成。
当产生第奇数个数时，只把当前数字最末位改变（0变1，1变0）
当产生第偶数个数时，先找到最右边的一个1，把它左边的数字改变。
用这个规则产生的4位格雷码序列如下：
0000
0001
0011
0010
0110
0111
0101
0100
1100
1101
1111
1110
1010
1011
1001
1000

#include<bits/stdc++.h>
using namespace std;

void show(int a,int n)  
{  
    int i;  
    int msk = 1;  
    for(i=0; i<n-1; i++) msk = msk << 1;  
    for(i=0; i<n; i++){  
        printf((a & msk)? "1" : "0");  
        msk = msk >> 1;  
    }  
    printf("\n");  
}   

void f(int n)  
{  
    int i;  
    int num = 1;  
    for(i=0; i<n; i++) num = num<<1;  

    int a = 0;  
    for(i=0; i<num; i++){  
        show(a,n);  

        if(i%2==0){  
            a = a ^ 1;  
        }  
        else{  
            a = __a^((a&(-a))<<1)__ ; 
        }  
    }  
}  

int main()  
{  
    f(4);  
    return 0;  
}  

读题分析解决的问题点在哪，问题点在f()，不在show
lowbit(X) x&-x  

网上的一种普遍方法就是使用lowbit的原理（a&-a），lowbit操作会消去所有高位的1，只留下最低位1和其后面的0。

例如a=1110进行操作，-a即为0010，a&-a得0010，由于题意中偶数时要处理最左面1的前一位，所以要对a&-a进行左移一位，

再与原数进行异或，即可达到改变其前一位的目的，如：（a&-a）<<1即0010<<1得0100，在使1110^0100 = 1010，达成改变效果。

